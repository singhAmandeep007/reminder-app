{"version":3,"file":"static/js/875.ae19ff06.chunk.js","mappings":"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","sources":["../node_modules/lucide-react/src/icons/ellipsis-vertical.ts","../node_modules/lucide-react/src/icons/ellipsis.ts","../node_modules/lucide-react/src/icons/plus.ts","../node_modules/lucide-react/src/icons/refresh-ccw.ts","../node_modules/lucide-react/src/icons/trash.ts","../node_modules/react-resizable-panels/dist/react-resizable-panels.browser.esm.js"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name EllipsisVertical\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxIiAvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iNSIgcj0iMSIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjE5IiByPSIxIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/ellipsis-vertical\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst EllipsisVertical = createLucideIcon('EllipsisVertical', [\n  ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],\n  ['circle', { cx: '12', cy: '5', r: '1', key: 'gxeob9' }],\n  ['circle', { cx: '12', cy: '19', r: '1', key: 'lyex9k' }],\n]);\n\nexport default EllipsisVertical;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Ellipsis\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxIiAvPgogIDxjaXJjbGUgY3g9IjE5IiBjeT0iMTIiIHI9IjEiIC8+CiAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIxIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/ellipsis\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Ellipsis = createLucideIcon('Ellipsis', [\n  ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],\n  ['circle', { cx: '19', cy: '12', r: '1', key: '1wjl8i' }],\n  ['circle', { cx: '5', cy: '12', r: '1', key: '1pcz8c' }],\n]);\n\nexport default Ellipsis;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Plus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJNMTIgNXYxNCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Plus = createLucideIcon('Plus', [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'M12 5v14', key: 's699le' }],\n]);\n\nexport default Plus;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name RefreshCcw\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMCAwLTktOSA5Ljc1IDkuNzUgMCAwIDAtNi43NCAyLjc0TDMgOCIgLz4KICA8cGF0aCBkPSJNMyAzdjVoNSIgLz4KICA8cGF0aCBkPSJNMyAxMmE5IDkgMCAwIDAgOSA5IDkuNzUgOS43NSAwIDAgMCA2Ljc0LTIuNzRMMjEgMTYiIC8+CiAgPHBhdGggZD0iTTE2IDE2aDV2NSIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/refresh-ccw\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst RefreshCcw = createLucideIcon('RefreshCcw', [\n  ['path', { d: 'M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8', key: '14sxne' }],\n  ['path', { d: 'M3 3v5h5', key: '1xhq8a' }],\n  ['path', { d: 'M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16', key: '1hlbsb' }],\n  ['path', { d: 'M16 16h5v5', key: 'ccwih5' }],\n]);\n\nexport default RefreshCcw;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Trash\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMyA2aDE4IiAvPgogIDxwYXRoIGQ9Ik0xOSA2djE0YzAgMS0xIDItMiAySDdjLTEgMC0yLTEtMi0yVjYiIC8+CiAgPHBhdGggZD0iTTggNlY0YzAtMSAxLTIgMi0yaDRjMSAwIDIgMSAyIDJ2MiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/trash\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Trash = createLucideIcon('Trash', [\n  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],\n  ['path', { d: 'M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6', key: '4alrt4' }],\n  ['path', { d: 'M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2', key: 'v07s0e' }],\n]);\n\nexport default Trash;\n","import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\nconst useLayoutEffect_do_not_use_directly = useLayoutEffect;\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst useIsomorphicLayoutEffect = useLayoutEffect_do_not_use_directly ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: () => {\n      expandPanel(panelDataRef.current);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet currentCursorStyle = null;\nlet styleElement = null;\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    document.head.appendChild(styleElement);\n  }\n  styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  } else if (isTouchEvent(event)) {\n    const touch = event.touches[0];\n    if (touch && touch.clientX && touch.clientY) {\n      return {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n    }\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other â€”\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {HTMLElement[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nfunction updateListeners() {\n  ownerDocumentCounts.forEach((_, ownerDocument) => {\n    const {\n      body\n    } = ownerDocument;\n    body.removeEventListener(\"contextmenu\", handlePointerUp);\n    body.removeEventListener(\"mousedown\", handlePointerDown);\n    body.removeEventListener(\"mouseleave\", handlePointerMove);\n    body.removeEventListener(\"mousemove\", handlePointerMove);\n    body.removeEventListener(\"touchmove\", handlePointerMove);\n    body.removeEventListener(\"touchstart\", handlePointerDown);\n  });\n  window.removeEventListener(\"mouseup\", handlePointerUp);\n  window.removeEventListener(\"touchcancel\", handlePointerUp);\n  window.removeEventListener(\"touchend\", handlePointerUp);\n  if (registeredResizeHandlers.size > 0) {\n    if (isPointerDown) {\n      if (intersectingHandles.length > 0) {\n        ownerDocumentCounts.forEach((count, ownerDocument) => {\n          const {\n            body\n          } = ownerDocument;\n          if (count > 0) {\n            body.addEventListener(\"contextmenu\", handlePointerUp);\n            body.addEventListener(\"mouseleave\", handlePointerMove);\n            body.addEventListener(\"mousemove\", handlePointerMove);\n            body.addEventListener(\"touchmove\", handlePointerMove, {\n              passive: false\n            });\n          }\n        });\n      }\n      window.addEventListener(\"mouseup\", handlePointerUp);\n      window.addEventListener(\"touchcancel\", handlePointerUp);\n      window.addEventListener(\"touchend\", handlePointerUp);\n    } else {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"mousedown\", handlePointerDown);\n          body.addEventListener(\"mousemove\", handlePointerMove);\n          body.addEventListener(\"touchmove\", handlePointerMove, {\n            passive: false\n          });\n          body.addEventListener(\"touchstart\", handlePointerDown);\n        }\n      });\n    }\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nconst PRECISION = 10;\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toFixed(3).localeCompare(Math.abs(delta).toFixed(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  var _dataset;\n  //If the root element is the PanelGroup\n  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n    return rootElement;\n  }\n\n  //Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toFixed(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toFixed(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n  }, []);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      if (delta === 0) {\n        return;\n      }\n\n      // Support RTL layouts\n      const isHorizontal = direction === \"horizontal\";\n      if (document.dir === \"rtl\" && isHorizontal) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not changeâ€“\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n    }\n  }, []);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel-group\": \"\",\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onDragging,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n  useEffect(() => {\n    var _hitAreaMargins$coars, _hitAreaMargins$fine;\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (isActive) {\n        switch (action) {\n          case \"down\":\n            {\n              setState(\"drag\");\n              startDragging(resizeHandleId, event);\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(true);\n              }\n              break;\n            }\n          case \"move\":\n            {\n              const {\n                state\n              } = committedValuesRef.current;\n              if (state !== \"drag\") {\n                setState(\"hover\");\n              }\n              resizeHandler(event);\n              break;\n            }\n          case \"up\":\n            {\n              setState(\"hover\");\n              stopDragging();\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(false);\n              }\n              break;\n            }\n        }\n      } else {\n        setState(\"inactive\");\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      // Coarse inputs (e.g. finger/touch)\n      coarse: (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15,\n      // Fine inputs (e.g. mouse)\n      fine: (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5\n    }, setResizeHandlerState);\n  }, [direction, disabled, hitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-resize-handle-state\": state,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { Panel, PanelGroup, PanelResizeHandle, assert, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects };\n"],"names":["EllipsisVertical","createLucideIcon","cx","cy","r","key","Ellipsis","Plus","d","RefreshCcw","Trash","createElement","createContext","createRef","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","React","useId","toString","useLayoutEffect_do_not_use_directly","PanelGroupContext","displayName","useIsomorphicLayoutEffect","wrappedUseId","counter","useUniqueId","idFromParams","arguments","length","undefined","idFromUseId","idRef","current","PanelWithForwardedRef","_ref","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","rest","context","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","idIsFromProps","didLogMissingDefaultSizeWarning","prevConstraints","panelData","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","size","parseFloat","flexGrow","toFixed","Panel","props","ref","currentCursorStyle","styleElement","setGlobalCursorStyle","state","constraintFlags","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","EXCEEDED_HORIZONTAL_MIN","EXCEEDED_HORIZONTAL_MAX","getCursorStyle","document","head","appendChild","innerHTML","concat","isKeyDown","event","type","isMouseEvent","startsWith","isTouchEvent","getResizeEventCoordinates","x","clientX","y","clientY","touch","touches","Infinity","intersects","rectOne","rectTwo","strict","width","height","creates_stacking_context","node","getComputedStyle","position","zIndex","_get_parent","display","get_parent","is_flex_item","opacity","transform","webkitTransform","mixBlendMode","filter","webkitFilter","isolation","test","willChange","webkitOverflowScrolling","find_stacking_context","nodes","i","assert","get_z_index","Number","get_ancestors","ancestors","push","parentNode","ShadowRoot","host","isCoarsePointer","matchMedia","matches","getInputType","intersectingHandles","isPointerDown","ownerDocumentCounts","Map","panelConstraintFlags","registeredResizeHandlers","Set","handlePointerDown","target","recalculateIntersectingHandles","updateListeners","updateResizeHandlerStates","preventDefault","handlePointerMove","updateCursor","handlePointerUp","clear","_ref2","splice","targetElement","HTMLElement","forEach","data","element","dragHandleElement","hitAreaMargins","dragHandleRect","getBoundingClientRect","bottom","left","right","top","margin","coarse","fine","contains","a","b","common_ancestor","at","pop","z_indexes","childNodes","furthest_ancestors","child","Math","sign","compare","currentElement","didIntersect","parentElement","reportConstraintsViolation","resizeHandleId","flag","set","intersectsHorizontal","intersectsVertical","direction","removeChild","_","ownerDocument","body","removeEventListener","window","count","addEventListener","passive","action","setResizeHandlerState","isActive","includes","expectedCondition","message","console","error","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","_ref3","panelConstraints","panelConstraintsArray","panelIndex","min","adjustLayoutByDelta","_ref4","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","index","prevSize","localDelta","abs","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","safeSize","localeCompare","numeric","fuzzyLayoutsEqual","pivotIndex","unsafeSize","reduce","total","calculateAriaValues","_ref5","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","max","valueNow","getResizeHandleElementsForGroup","scope","Array","from","querySelectorAll","getResizeHandleElementIndex","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","panelGroupElement","getPanelGroupElement","rootElement","_dataset","dataset","panelGroupId","querySelector","getResizeHandleElement","useWindowSplitterPanelGroupBehavior","_ref6","committedValuesRef","eagerValuesRef","panelDataArray","setLayout","didWarnAboutMissingResizeHandle","resizeHandleElements","resizeHandleElement","setAttribute","round","removeAttribute","eagerValues","handles","cleanupFunctions","map","handleId","idBefore","idAfter","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","indexOf","getResizeHandlePanelIds","onKeyDown","defaultPrevented","cleanupFunction","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","calculateDeltaPercentage","initialDragState","keyboardResizeBy","shiftKey","movement","handleElement","initialCursorPosition","cursorPosition","groupElement","groupRect","calculateDragOffsetPercentage","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","value","getPanelGroupKey","autoSaveId","getPanelKey","panels","panel","JSON","stringify","sort","join","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","parse","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","panelKey","expandToSizes","Object","fromEntries","entries","validatePanelGroupLayout","_ref9","nextLayoutTotalSize","accumulated","remainingSize","defaultStorage","debounceMap","PanelGroupWithForwardedRef","_ref10","onLayout","panelGroupElementRef","dragState","setDragState","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","panelDataArrayChanged","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","safeLayout","debouncedSave","callback","durationMs","timeoutId","_len","args","_key","clearTimeout","setTimeout","debounce","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","findPanelDataIndex","prevPanelSize","get","baseSize","_ref8","precision","flexBasis","flexShrink","overflow","pointerEvents","computePanelFlexBoxStyle","isPanelExpanded","panelA","panelB","orderA","orderB","_loadSerializedPanelG","_state$panelKey","loadPanelGroupState","_ref7","numPanelsWithSizes","calculateUnsafeDefaultLayout","registerResizeHandle","dir","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","flexDirection","Provider","PanelGroup","prevPanelData","PanelResizeHandle","_ref12","disabled","onDragging","tabIndex","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","resizeHandler","setResizeHandler","_hitAreaMargins$coars","_hitAreaMargins$fine","_ownerDocumentCounts$","add","_ownerDocumentCounts$2","delete","_ref11","focus","useWindowSplitterResizeHandlerBehavior","onBlur","onFocus","role","touchAction","userSelect"],"sourceRoot":""}